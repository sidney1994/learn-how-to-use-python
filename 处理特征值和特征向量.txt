最近使用python进行数据处理，需要计算矩阵的特征值和特征向量，然后对特征值由小到大排序，去前k个特征值对应的特征向量（其实是自己实现双向2D PCA算法），感觉numpy中实现这个算法的方式很巧妙。

假设已经计算好了特征值evals=[0,2,5,3,1]和对应的特征向量evecs=[[1,1],[2,3],[4,5],[7,7],[6,8]]。首先要对特征值排序，这里要用到argmax这个函数：

import numpy as np

evals=np.array([0,2,5,3,1])
evecs=np.array([[1,1],[2,3],[4,5],[7,7],[6,8]])

sorted_indices = np.argsort(evals)

上面得到的sorted_indices就是特征值排序后的结果，巧妙的是这里是用数组下标来表示的，也就是说其中存放的是特征值由小到大的顺序排序时对应的下标[0, 4, 1, 3, 2]，而不是直接存放特征值。

下一步就是取前k大的特征向量了：

topk_evecs = evecs[:,sorted_indices[:-k-1:-1]]

一句话就可以搞定了，这里利用的numpy数组的便利。

numpy数组的索引除了指定第一维外，还可以指定特定的列数，上面的evecs[ : , …]逗号后面省略的部分就是指定对应要保留的特征向量的列号（特征向量按列存放）。

sorted_indices[:-k-1:-1]则利用切片的语法特性，保留了前K大的特征值对应的下标。切片有三个参数[start : end : step]，当step为-1时，表示逆序，从最后一个元素开始，一直到第end+1个元素为止。sorted_indices[:-k-1:-1]则表示从最后一个元素一直到第k个为止的所有下标，也就是前k大的特征值对应的下标。

这样通过很简洁的语句，就完成了将特征值排序并取前k大特征值对应的特征向量这一功能。